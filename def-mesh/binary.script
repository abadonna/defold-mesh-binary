local reader = require "def-mesh.reader"
go.property('opaque', resource.material())
go.property('transparent', resource.material())

go.property('t1', resource.texture())
go.property('t2', resource.texture())
go.property('t3', resource.texture())
go.property('t4', resource.texture())
go.property('t5', resource.texture())
go.property('t6', resource.texture())
go.property('t7', resource.texture())
go.property('t8', resource.texture())
go.property('t9', resource.texture())
go.property('t10', resource.texture())
go.property('t11', resource.texture())
go.property('t12', resource.texture())
go.property('t13', resource.texture())
go.property('t14', resource.texture())
go.property('t15', resource.texture())
go.property('t16', resource.texture())
go.property('t17', resource.texture())
go.property('t18', resource.texture())
go.property('t19', resource.texture())
go.property('t20', resource.texture())

go.property("v1", resource.buffer("/def-mesh/buffers/dummy1.buffer"))
go.property("v2", resource.buffer("/def-mesh/buffers/dummy2.buffer"))
go.property("v3", resource.buffer("/def-mesh/buffers/dummy3.buffer"))
go.property("v4", resource.buffer("/def-mesh/buffers/dummy4.buffer"))
go.property("v5", resource.buffer("/def-mesh/buffers/dummy5.buffer"))
go.property("v6", resource.buffer("/def-mesh/buffers/dummy6.buffer"))
go.property("v7", resource.buffer("/def-mesh/buffers/dummy7.buffer"))
go.property("v8", resource.buffer("/def-mesh/buffers/dummy8.buffer"))
go.property("v9", resource.buffer("/def-mesh/buffers/dummy9.buffer"))
go.property("v10", resource.buffer("/def-mesh/buffers/dummy10.buffer"))
go.property("v11", resource.buffer("/def-mesh/buffers/dummy11.buffer"))
go.property("v12", resource.buffer("/def-mesh/buffers/dummy12.buffer"))
go.property("v13", resource.buffer("/def-mesh/buffers/dummy13.buffer"))
go.property("v14", resource.buffer("/def-mesh/buffers/dummy14.buffer"))
go.property("v15", resource.buffer("/def-mesh/buffers/dummy15.buffer"))
go.property("v16", resource.buffer("/def-mesh/buffers/dummy16.buffer"))
go.property("v17", resource.buffer("/def-mesh/buffers/dummy17.buffer"))
go.property("v18", resource.buffer("/def-mesh/buffers/dummy18.buffer"))
go.property("v19", resource.buffer("/def-mesh/buffers/dummy19.buffer"))
go.property("v20", resource.buffer("/def-mesh/buffers/dummy20.buffer"))
go.property("v21", resource.buffer("/def-mesh/buffers/dummy21.buffer"))
go.property("v22", resource.buffer("/def-mesh/buffers/dummy22.buffer"))
go.property("v23", resource.buffer("/def-mesh/buffers/dummy23.buffer"))
go.property("v24", resource.buffer("/def-mesh/buffers/dummy24.buffer"))
go.property("v25", resource.buffer("/def-mesh/buffers/dummy25.buffer"))
go.property("v26", resource.buffer("/def-mesh/buffers/dummy26.buffer"))
go.property("v27", resource.buffer("/def-mesh/buffers/dummy27.buffer"))
go.property("v28", resource.buffer("/def-mesh/buffers/dummy28.buffer"))
go.property("v29", resource.buffer("/def-mesh/buffers/dummy29.buffer"))
go.property("v30", resource.buffer("/def-mesh/buffers/dummy30.buffer"))
go.property("v31", resource.buffer("/def-mesh/buffers/dummy31.buffer"))
go.property("v32", resource.buffer("/def-mesh/buffers/dummy32.buffer"))
go.property("v33", resource.buffer("/def-mesh/buffers/dummy33.buffer"))
go.property("v34", resource.buffer("/def-mesh/buffers/dummy34.buffer"))
go.property("v35", resource.buffer("/def-mesh/buffers/dummy35.buffer"))
go.property("v36", resource.buffer("/def-mesh/buffers/dummy36.buffer"))
go.property("v37", resource.buffer("/def-mesh/buffers/dummy37.buffer"))
go.property("v38", resource.buffer("/def-mesh/buffers/dummy38.buffer"))
go.property("v39", resource.buffer("/def-mesh/buffers/dummy39.buffer"))
go.property("v40", resource.buffer("/def-mesh/buffers/dummy40.buffer"))

function init(self)
	self.time = 0
	self.meshes = {}
	self.total_frames = 0
	if BUFFERS == nil then
		BUFFERS = {self.v1, self.v2, self.v3, self.v4, self.v5, self.v6, self.v7, self.v8, self.v9, self.v10,
		self.v11, self.v12, self.v13, self.v14, self.v15, self.v16, self.v17, self.v18, self.v19, self.v20,
		self.v21, self.v22, self.v23, self.v24, self.v25, self.v26, self.v27, self.v28, self.v29, self.v30,
		self.v31, self.v32, self.v33, self.v34, self.v35, self.v36, self.v37, self.v38, self.v39, self.v40}
	end
end

function final(self)
	for _, mesh in pairs(self.meshes) do
		mesh_utils.clear_data(mesh);
		table.insert(BUFFERS, go.get(mesh.url, "vertices")) --return buffer to pool
	end
end

local function set_frame(self, frame, frame_blend, blend)
	for _, mesh in pairs(self.meshes) do
		mesh.set_frame(frame, frame_blend, blend)
	end
end

local function get_texture_hash(tex_name)
	local fname = string.gsub(tex_name, ".png", ".texturec")
	fname = string.gsub(fname, ".jpg", ".texturec")
	fname = string.gsub(fname, ".tif", ".texturec")
	fname = string.gsub(fname, ".tiff", ".texturec")
	return hash("/textures/" .. fname)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("load_mesh") then
		reader.init_from_resource(message.path)
		while not reader.eof() and #BUFFERS > 0 do
			for _, mesh in ipairs(reader.read_mesh()) do --can be multiple meshes if initial mesh contains multiple materials
				pprint(mesh.name .. " " .. #mesh.faces .. " triangles")

				if #BUFFERS == 0 then
					pprint("No more buffers")
					return
				end

				if mesh.frames then
					self.total_frames = #mesh.frames
				end

				local buf = mesh.create_buffer()
				local f = mesh.material.type == 0 and "#factory" or "#factory_trans"
				
				mesh.id = factory.create(f, mesh.position, mesh.rotation, {}, mesh.scale)
				mesh.url = msg.url(nil, mesh.id, "mesh")

				if self.opaque ~= hash("") and mesh.material.type == 0 then
					go.set(mesh.url, "material", self.opaque)
				elseif self.transparent ~= hash("") and mesh.material.type ~= 0 then
					go.set(mesh.url, "material", self.transparent)
				end
				

				local v = table.remove(BUFFERS)
				resource.set_buffer(v, buf)
				go.set(mesh.url, "vertices", v)

				mesh.apply_armature()
				local options = vmath.vector4(0.0)
				local options_specular = vmath.vector4(0.0)
				options_specular.y = mesh.material.specular.value
				options_specular.z = mesh.material.roughness.value

				options.z = mesh.material.type

				if mesh.material.texture then
					options.x = 1.0
					if not pcall(function()
						local texture = get_texture_hash(mesh.material.texture)
						go.set(mesh.url, "texture0", texture)
						options.x = 1.0
					end) then
						pprint(mesh.material.texture .. " not found")
					end
				end

				if mesh.material.normal then
					if not pcall(function()
						local texture = get_texture_hash(mesh.material.normal.texture)
						go.set(mesh.url, "texture1", texture)
						options.y = mesh.material.normal.strength
					end) then
						pprint(mesh.material.normal.texture .. " not found")
					end
				end

				if mesh.material.specular.texture then
					if not pcall(function()
						local texture = get_texture_hash(mesh.material.specular.texture)
						go.set(mesh.url, "texture2", texture)
						options_specular.x = 1.0 + mesh.material.specular.invert
						if mesh.material.specular.ramp then
							local r = mesh.material.specular.ramp
							go.set(mesh.url, "spec_ramp", vmath.vector4(r.p1, r.v1, r.p2, r.v2))
						end
					end) then
						pprint(mesh.material.specular.texture .. " not found")
					end
				end

				if mesh.material.roughness.texture then
					if not pcall(function()
						local texture = get_texture_hash(mesh.material.roughness.texture)
						go.set(mesh.url, "texture2", texture) -- roughness and specular are usually the same?
						options_specular.w = 1.0
						if mesh.material.roughness.ramp then
							local r = mesh.material.roughness.ramp
							go.set(mesh.url, "rough_ramp", vmath.vector4(r.p1, r.v1, r.p2, r.v2))
						end
					end) then
						pprint(mesh.material.roughness.texture .. " not found")
					end
				end

				go.set(mesh.url, "base_color", mesh.material and mesh.material.color or vmath.vector4(0.8,0.8,0.8,1))
				go.set(mesh.url, "options", options)
				go.set(mesh.url, "options_specular", options_specular)
				
				self.meshes[mesh.name] = mesh
			end
		end

		--set hierarchy
		for key, mesh in pairs(self.meshes) do
			if mesh.parent and self.meshes[mesh.parent] then
				go.set_parent(mesh.id, self.meshes[mesh.parent].id, false)
			else
				go.set_parent(mesh.id, ".", false)
				if mesh.parent then
					go.set_position(mesh.world_.position, mesh.id)
					go.set_scale(mesh.world_.scale, mesh.id)
					go.set_rotation(mesh.world_.rotation, mesh.id)
				end
			end
		end

		if message.animations then
			local res = sys.load_resource(message.animations)
			if res then
				self.animations = loadstring(res)()
			end
		end
		
		msg.post(sender, "mesh_loaded", {frames = self.total_frames})
		
	elseif message_id == hash("set_frame") then
		set_frame(self, message.frame)

	elseif message_id == hash("set_shapes") then
		for _, mesh in pairs(self.meshes) do
			mesh.set_shapes(message.shapes)
		end

	elseif message_id == hash("play") then
		local animation = message.anim and self.animations[message.anim] or {start = message.start, finish = message.finish}
		if self.animation and message.blend_frames then
			self.blend_from = self.frame
			self.last_blend_frame = self.animation.finish
			self.blend = 1
			self.blend_step = 1./message.blend_frames
		end
		self.animation = animation
		self.frame = self.animation.start
		set_frame(self, self.blend_from or self.frame )
		
		self.sender = sender
		
	elseif message_id == hash("reset") then
		for _, mesh in pairs(self.meshes) do
			table.insert(BUFFERS, go.get(mesh.url, "vertices"))
			go.set(mesh.url, "vertices", self.v1)
		end
	end
end

function update(self, dt)
	if self.animation then
		self.time = self.time + dt
		if self.time > .03 then
			self.time = 0.0
			if self.blend_from then
				self.blend = self.blend - self.blend_step
				
				if self.blend > 0 then
					self.frame = math.min(self.frame + 1, self.animation.finish)
					self.blend_from = self.blend_from + 1
					set_frame(self, self.frame, self.blend_from, self.blend)
					return
				end

				self.blend_from = nil
			end

			if self.frame > self.animation.finish then
				self.animation = nil
				msg.post(self.sender, "mesh_animation_done")
			else
				self.frame = self.frame + 1
			end
			
			set_frame(self, self.frame)
		end
	end

	
end